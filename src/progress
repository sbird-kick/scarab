// Pointer to the global hash table for tracking instruction cycles
starlab_hash_table* global_starlab_ht_ptr = (starlab_hash_table*) voided_global_starlab_ht_ptr;

// Create the global hash table if it does not exist
if (global_starlab_ht_ptr == NULL) 
{
    global_starlab_ht_ptr = starlab_create_table(INITIAL_TABLE_SIZE, sizeof(starlab_table_value));
}

// Pointer to the hash table for tracking instruction type tuples and their total cycles
starlab_hash_table* starlab_types_table_ptr = (starlab_hash_table*) voided_global_starlab_types_ht;

if (starlab_types_table_ptr == NULL) 
{
    starlab_types_table_ptr = starlab_create_table(INITIAL_TABLE_SIZE, sizeof(unsigned long));
}

// Create a string representation of the instruction's address and opcode
char address_as_string[128] = {0};
sprintf(address_as_string, "%016llX%s", op->fetch_addr, starlab_get_opcode_string(op->table_info->op_type));

// Check if the instruction's address and opcode combination is already in the global hash table
if (!starlab_search(global_starlab_ht_ptr, address_as_string)) 
{
    // If not found, insert the instruction's fetch cycle into the global hash table
    starlab_table_value temp_val_to_insert = {op->fetch_cycle, op->fetch_cycle};
    starlab_insert(global_starlab_ht_ptr, address_as_string, &temp_val_to_insert);
    strncpy(prev_address_as_string, address_as_string, 128);  // Update the previous address string
} 

else 
{
    // If found, retrieve the previous fetch cycle for the instruction
    unsigned long prev_inst_prev_fetch;
    if (starlab_search(global_starlab_ht_ptr, prev_address_as_string) == NULL) 
    {
        prev_inst_prev_fetch = prev_instruction_time;
    } 
    else 
    {
        prev_inst_prev_fetch = ((starlab_table_value*) starlab_search(global_starlab_ht_ptr, prev_address_as_string))->prev_fetch;
    }

    // Calculate the clock cycles taken by the instruction tuple
    unsigned long cc_taken_by_tuple = op->exec_cycle - prev_inst_prev_fetch;

    // Remove the instruction's address and opcode combination from the global hash table
    starlab_delete_key(global_starlab_ht_ptr, address_as_string);

    // Create a string representation of the instruction type tuple
    char tuple_of_types[256] = {0};
    sprintf(tuple_of_types, "<%s,%s>", prev_instruction_class, starlab_get_opcode_string(op->table_info->op_type));

    // Check if the instruction type tuple is already in the types hash table
    if (!starlab_search(starlab_types_table_ptr, tuple_of_types)) {
        // If not found, insert the clock cycles taken by the tuple into the types hash table
        unsigned long insert_val = cc_taken_by_tuple;
        starlab_insert(starlab_types_table_ptr, tuple_of_types, &insert_val);
    } else {
        // If found, update the clock cycles taken by the tuple in the types hash table
        unsigned long insert_val = *(unsigned long*) starlab_search(starlab_types_table_ptr, tuple_of_types) + cc_taken_by_tuple;
        starlab_insert(starlab_types_table_ptr, tuple_of_types, &insert_val);
    }

    // Update the previous instruction time, class, and address string
    prev_instruction_time = op->fetch_cycle;
    strncpy(prev_instruction_class, starlab_get_opcode_string(op->table_info->op_type), 100);
    strncpy(prev_address_as_string, address_as_string, 128);
}
